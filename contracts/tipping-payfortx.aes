// ISC License
//
// Copyright (c) 2020, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

@compiler >= 4

include "List.aes"
include "Func.aes"
include "Option.aes"

payable contract WaelletTipAnyBasic =

  type tip_string = string * string
  datatype tiptype = Tip(tip) | ReTip(retip)

  // TODO: try out option with separate maps for tips/retips
  // TODO: with tip_urls : map(string, list(int) * list(int)) eventually
  record state =
    { tips               : map(int, tiptype)
    , tip_urls           : map(string, list(int))
    , pay_for_tx_service : address }

  record tip =
    { id        : int
    , sender    : address
    , timestamp : int
    , repaid    : bool
    , url       : string
    , amount    : int
    , title     : string
    , retip_ids : list(int) }

  record retip =
    { sender : address
    , repaid : bool
    , amount : int }

  datatype event =
    TipReceived(address, int, string)
    | ReTipReceived(address, int, string)
    | TipWithdrawn(address, int, string)

  entrypoint init(pay_for_tx_service : address) : state =
    { tips               = {},
      tip_urls           = {},
      pay_for_tx_service = pay_for_tx_service }

  entrypoint get_state() : state = state

  // in testing each tip for the same url added +5 gas to the execution cost
  // adding tips for new urls is static after 7 entries in gas usage
  payable stateful entrypoint tip(url : string, title : string) : unit =
    let id = Map.size(state.tips)
    let tip = { id        = id,
                sender    = Call.caller,
                timestamp = Chain.timestamp,
                repaid    = false,
                url       = url,
                amount    = Call.value,
                title     = title,
                retip_ids = [] }
    put(state{ tips[id] = Tip(tip), tip_urls[url = []] @ ids = id :: ids })
    Chain.event(TipReceived(Call.caller, Call.value, url))

  // in testing each retip added +10 gas to the execution cost
  payable stateful entrypoint retip(id : int) : unit =
    require(Map.member(id, state.tips), "ID_UNKNOWN")
    let retip = { sender = Call.caller,
                  repaid = false,
                  amount = Call.value }
    let retip_id = Map.size(state.tips)
    let tip_url = get_tip_type(id).url

    put(state{ tips[retip_id] = ReTip(retip), tip_urls[tip_url = []] @ ids = retip_id :: ids })

    let tip = get_tip_type(id)
    let tip' = tip{ retip_ids @ retip_ids = retip_id :: retip_ids }
    put(state{ tips[id] = Tip(tip') })
    Chain.event(ReTipReceived(Call.caller, Call.value, tip_url))

  function get_tip_type(id : int) : tip =
    switch(state.tips[id])
      Tip(tip) => tip
      _        => abort("ONLY_RETIP_TIP")

  // gas usage increases ~300 for each retip added
  // iterating already repaid at ~110 gas
  stateful entrypoint claim(url : string, payout_receiver : address) =
    require_allowed_pay_for_tx_service()
    let tip_ids = Map.lookup_default(url, state.tip_urls, [])
    let amount = sum_amout_and_set_repaid(tip_ids, 0)
    require(amount != 0, "NO_ZERO_AMOUNT_PAYOUT")
    Chain.spend(payout_receiver, amount)
    Chain.event(TipWithdrawn(payout_receiver, amount, url))

  stateful function
    sum_amout_and_set_repaid([], n) = n
    sum_amout_and_set_repaid(tid :: tids, n) =
      switch(state.tips[tid])
        Tip({repaid = true}) => sum_amout_and_set_repaid(tids, n)
        Tip(t)               =>
          put(state{ tips[tid] = Tip(t{ repaid = true }) })
          sum_amout_and_set_repaid(tids, n + t.amount)
        ReTip({repaid = true}) => sum_amout_and_set_repaid(tids, n)
        ReTip(t)               =>
          put(state{ tips[tid] = ReTip(t{ repaid = true }) })
          sum_amout_and_set_repaid(tids, n + t.amount)

  stateful function migrate_contract(new_contract : address) =
    // TODO: disallow use of this contract?
    require_allowed_pay_for_tx_service()
    Chain.spend(new_contract, Contract.balance)

  function require_allowed_pay_for_tx_service() =
    require(Call.caller == state.pay_for_tx_service, "NOT_ALLOWED")
