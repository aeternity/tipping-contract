// ISC License
//
// Copyright (c) 2020, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

@compiler >= 4

include "List.aes"
include "Func.aes"
include "Option.aes"

payable contract WaelletTipAnyBasic =

  type tip_string = string * string

  // TODO: add re-tips to state

  // TODO: maybe only have one map (tipstring, tiptype) where tiptype may be tip or retip
  // TODO: then we can have in tip, list/map of retips so only have one layer of linear complexity
  // TODO: consider removing int ids again in favour of tip_string for optimized gas (TEST!!)
  record state =
    { tips               : map(tip_string, tip)
    , tips_index         : map(int, tip_string)
    , tip_url_titles     : map(string, list(string))
    , tip_retips         : map(int, map(int, retip))
    , pay_for_tx_service : address }

  record tip =
    { id        : int
    , sender    : address
    , timestamp : int
    , repaid    : bool
    , amount    : int
    , title     : string }

  record retip =
    { sender : address
    , repaid : bool
    , amount : int }

  datatype event =
    TipReceived(address, int, string)
    | TipWithdrawn(address, int, string)

  entrypoint init(pay_for_tx_service : address) : state =
    { tips               = {},
      tips_index         = {},
      tip_url_titles     = {},
      tip_retips         = {},
      pay_for_tx_service = pay_for_tx_service }

  entrypoint get_state() : state = state

  payable stateful entrypoint tip(url : string, title : string) : unit =
    let tip_url_title = (url, title)
    let id = Map.size(state.tips_index)
    let tip = { id        = id,
                sender    = Call.caller,
                timestamp = Chain.timestamp,
                repaid    = false,
                amount    = Call.value,
                title     = title }
    put(state{ tips[tip_url_title] = tip,
               tips_index[id] = tip_url_title,
               tip_url_titles[url = []] @ titles = title :: titles })
    Chain.event(TipReceived(Call.caller, Call.value, url))

  payable stateful entrypoint retip(id : int) : unit =
    require(Map.member(id, state.tips_index), "ID_UNKNOWN")
    let retip = { sender = Call.caller,
                  repaid = false,
                  amount = Call.value }
    put(state{ tip_retips[id = {}] @ retips = retips{ [Map.size(retips)] = retip } })

  stateful entrypoint claim(url : string, payout_receiver : address) =
    require_allowed_pay_for_tx_service()
    let url_strings = List.map((title) => (url, title), Map.lookup_default(url, state.tip_url_titles, []))

    let get_retips_set_repaid = (id) =>
      let retips = Map.to_list(Map.lookup_default(id, state.tip_retips, {}))
      let get_retip_amount_set_repaid = (id_retip) => switch(id_retip)
        (retip_id, retip) =>
          if(retip.repaid)
            0
          else
            put(state{tip_retips[tip_url_title] @ retips = retips{ [retip_id].repaid = true } })
            tip.amount
      List.sum(List.map(get_retip_amount_set_repaid, retips))

    let get_amount_set_repaid = (tip_url_title) => switch(Map.lookup(tip_url_title, state.tips))
      None      => 0
      Some(tip) =>
        if(tip.repaid)
          0 + get_retips_set_repaid(tip.id)
        else
          put(state{tips[tip_url_title].repaid = true})
          tip.amount + get_retips_set_repaid(tip.id)

    let tips_amount = List.sum(List.map(get_amount_set_repaid, url_strings))

    require(amount != 0, "NO_ZERO_AMOUNT_PAYOUT")
    Chain.spend(payout_receiver, amount)
    Chain.event(TipWithdrawn(payout_receiver, amount, url))

  stateful function migrate_contract(new_contract : address) =
    // TODO: disallow use of this contract?
    require_allowed_pay_for_tx_service()
    Chain.spend(new_contract, Contract.balance)

  function require_allowed_pay_for_tx_service() =
    require(Call.caller == state.pay_for_tx_service, "NOT_ALLOWED")
