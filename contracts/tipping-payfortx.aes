// ISC License
//
// Copyright (c) 2020, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

@compiler >= 4

contract TippingPayForTx =

  type tip_id       = int
  type url_id       = int
  type retip_id     = int
  type url          = string
  type claim_id     = int

  record tip = { sender    : address
               , title     : string
               , claim_id  : claim_id
               , timestamp : int
               , url_id    : url_id
               , amount    : int
               , retips    : list(int) }

  record retip = { sender   : address
                 , amount   : int
                 , claim_id : claim_id }

  record state = { urls               : map(url, url_id)
                 , claim              : map(url_id, claim_id * int)
                 , url_index          : map(url_id, url)
                 , tips               : map(tip_id, tip)
                 , retips             : map(retip_id, retip)
                 , pay_for_tx_service : address }

  datatype event =
    TipReceived(address, int, string)
    | ReTipReceived(address, int, string)
    | TipWithdrawn(address, int, string)

  entrypoint init(pay_for_tx_service : address) : state =
    { urls = {}, claim = {}, url_index = {}, tips = {}, retips = {}, pay_for_tx_service = pay_for_tx_service }

  entrypoint get_state() : state = state

  payable stateful entrypoint tip(url : string, title : string) : unit =
    let url_id = get_url_id(url)
    let (last_claim_id, amount) = state.claim[url_id = (0, 0)]
    let next_claim_id = last_claim_id + 1
    let tip_id = Map.size(state.tips)
    let tip = { sender    = Call.caller
              , title     = title
              , claim_id  = last_claim_id
              , timestamp = Chain.timestamp
              , url_id    = url_id
              , amount    = Call.value
              , retips    = [] }
    put(state{ tips[tip_id] = tip,
               claim[url_id] = (last_claim_id, amount + Call.value) })
    Chain.event(TipReceived(Call.caller, Call.value, url))

  payable stateful entrypoint retip(tip_id : tip_id) : unit =
    require(Map.member(tip_id, state.tips), "TIP_NOT_EXISTING")
    let tip = state.tips[tip_id]
    let (last_claim_id, amount) = state.claim[tip.url_id]
    let next_claim_id = last_claim_id + 1
    let retip_id = Map.size(state.retips)
    let retip = { sender   = Call.caller
                , claim_id = next_claim_id
                , amount   = Call.value }
    put(state{ retips[retip_id] = retip,
               claim[tip.url_id] = (next_claim_id, amount + Call.value) })
    Chain.event(ReTipReceived(Call.caller, Call.value, state.url_index[tip.url_id]))

  stateful entrypoint claim(url : string, payout_receiver : address) =
    require_allowed_pay_for_tx_service()
    require(Map.member(url, state.urls), "URL_NOT_EXISTING")
    let url_id = state.urls[url]
    let (last_claim_id, amount) = state.claim[url_id]
    let next_claim_id = last_claim_id + 1
    require(amount != 0, "NO_ZERO_AMOUNT_PAYOUT")
    Chain.spend(payout_receiver, amount)
    Chain.event(TipWithdrawn(payout_receiver, amount, url))
    put(state{ claim[url_id] = (next_claim_id, 0) })

  stateful function get_url_id(url) =
    switch(Map.lookup(url, state.urls))
      Some(url_id) => url_id
      None =>
        let url_id = Map.size(state.urls)
        put(state{ urls[url] = url_id, url_index[url_id] = url })
        url_id

  function require_allowed_pay_for_tx_service() =
    require(Call.caller == state.pay_for_tx_service, "NOT_ALLOWED")
