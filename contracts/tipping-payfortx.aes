// ISC License
//
// Copyright (c) 2020, aeternity developers
//
// Permission to use, copy, modify, and/or distribute this software for any
// purpose with or without fee is hereby granted, provided that the above
// copyright notice and this permission notice appear in all copies.
//
// THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
// REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
// AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
// INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
// LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE
// OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
// PERFORMANCE OF THIS SOFTWARE.


// THIS IS NOT SECURITY AUDITED
// DO NEVER USE THIS WITHOUT SECURITY AUDIT FIRST

@compiler >= 4

include "List.aes"
include "Func.aes"
include "Option.aes"

payable contract WaelletTipAnyBasic =

  record state =
    { tips               : map(int, tip)
    , retips             : map(int, retip)
    , tip_urls           : map(string, list(int))
    , retip_urls         : map(string, list(int))
    , pay_for_tx_service : address }

  record tip =
    { id        : int
    , sender    : address
    , timestamp : int
    , repaid    : bool
    , url       : string
    , amount    : int
    , title     : string
    , retip_ids : list(int) }

  record retip =
    { sender : address
    , repaid : bool
    , amount : int }

  datatype event =
    TipReceived(address, int, string)
    | ReTipReceived(address, int, string)
    | TipWithdrawn(address, int, string)

  entrypoint init(pay_for_tx_service : address) : state =
    { tips               = {},
      retips             = {},
      tip_urls           = {},
      retip_urls         = {},
      pay_for_tx_service = pay_for_tx_service }

  entrypoint get_state() : state = state

  payable stateful entrypoint tip(url : string, title : string) : unit =
    let id = Map.size(state.tips)
    let tip = { id        = id,
                sender    = Call.caller,
                timestamp = Chain.timestamp,
                repaid    = false,
                url       = url,
                amount    = Call.value,
                title     = title,
                retip_ids = [] }
    put(state{ tips[id] = tip, tip_urls[url = []] @ ids = id :: ids })
    Chain.event(TipReceived(Call.caller, Call.value, url))

  // in testing each retip added +10 gas to the execution cost
  payable stateful entrypoint retip(id : int) : unit =
    require(Map.member(id, state.tips), "ID_UNKNOWN")
    let retip = { sender = Call.caller,
                  repaid = false,
                  amount = Call.value }
    let retip_id = Map.size(state.retips)
    let tip_url = state.tips[id].url

    put(state{ retips[retip_id] = retip, retip_urls[tip_url = []] @ retip_ids = retip_id :: retip_ids })
    put(state{ tips[id].retip_ids @ retip_ids = retip_id :: retip_ids })
    Chain.event(ReTipReceived(Call.caller, Call.value, tip_url))

  stateful entrypoint claim(url : string, payout_receiver : address) =
    require_allowed_pay_for_tx_service()
    let tip_ids = Map.lookup_default(url, state.tip_urls, [])
    let tip_amount = sum_amout_and_set_repaid(tip_ids, 0)

    let retip_ids = Map.lookup_default(url, state.retip_urls, [])
    let retip_amount = sum_amout_and_set_repaid_retip(retip_ids, 0)

    let amount = tip_amount + retip_amount
    require(amount != 0, "NO_ZERO_AMOUNT_PAYOUT")
    Chain.spend(payout_receiver, amount)
    Chain.event(TipWithdrawn(payout_receiver, amount, url))

  stateful function
    sum_amout_and_set_repaid([], n) = n
    sum_amout_and_set_repaid(tid :: tids, n) =
      if(state.tips[tid].repaid)
        0
      else
        put(state{ tips[tid].repaid = true })
        sum_amout_and_set_repaid(tids, n + state.tips[tid].amount)
  stateful function
    sum_amout_and_set_repaid_retip([], n) = n
    sum_amout_and_set_repaid_retip(tid :: tids, n) =
      if(state.retips[tid].repaid)
        0
      else
        put(state{ retips[tid].repaid = true })
        sum_amout_and_set_repaid_retip(tids, n + state.retips[tid].amount)

  stateful function migrate_contract(new_contract : address) =
    // TODO: disallow use of this contract?
    require_allowed_pay_for_tx_service()
    Chain.spend(new_contract, Contract.balance)

  function require_allowed_pay_for_tx_service() =
    require(Call.caller == state.pay_for_tx_service, "NOT_ALLOWED")
